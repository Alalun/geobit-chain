package io.geobit.chain.dispatchers;

import static io.geobit.statics.Log.log;
import io.geobit.chain.providers.BalanceProvider;
import io.geobit.chain.providers.BalanceProviders;
import io.geobit.chain.providers.ReceivedProvider;
import io.geobit.chain.providers.ReceivedProviders;
import io.geobit.chain.providers.runnable.BalanceRunnable;
import io.geobit.chain.providers.runnable.FutureBalanceCallback;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;
import com.google.common.util.concurrent.SettableFuture;

public class BalanceAndReceivedDispatchers 
implements BalanceProvider, ReceivedProvider {

	private ExecutorService              executor     = Executors.newFixedThreadPool(5);
	private ListeningExecutorService moreExecutor     = MoreExecutors.listeningDecorator(executor);

	private BalanceProviders     balanceProviders     = new BalanceProviders();
	private ReceivedProviders    receivedProviders    = new ReceivedProviders();
	private LoadingCache<String, Long> cache;

	private static BalanceAndReceivedDispatchers me;

	public static BalanceAndReceivedDispatchers getInstance() {
		if(me==null) {
			me=new BalanceAndReceivedDispatchers();
		}	
		return me;
	}

	private BalanceAndReceivedDispatchers() {
		initializeCache();
	}

	private void initializeCache() {
		cache = CacheBuilder.newBuilder()
				.maximumSize(1000000)
				.recordStats()
				.build(
						new CacheLoader<String, Long>() {
							public Long load(String cacheAddress) {
								log("BalanceAndReceivedDispatchers cache LOADING key " + cacheAddress);
								if( cacheAddress.startsWith("b/") )
									return getBalance(cacheAddress.substring(2) );
								else if( cacheAddress.startsWith("r/") )
									return getReceived(cacheAddress.substring(2) );
								else
									throw new RuntimeException("BalanceAndReceivedDispatchers cache address invalid");			
							}
						}
						);
	}


	@Override
	public String getPrefix() {
		return "mixed";
	}

	@Override
	public Long getBalance(String address) {
		return getBalance(address,0);
	}

	public Long getBalance(String address, int cont) {
		if(cont>3)
			return null;
		Long valCache = cache.getIfPresent("b/"+address);
		BalanceProvider bal1 = balanceProviders.take();
		BalanceProvider bal2 = balanceProviders.takeDifferent(bal1);
		System.out.println("bal1=" + bal1 + " bal2="+bal2);
		Callable<Long> runner1    = new BalanceRunnable(bal1, address);
		Callable<Long> runner2   = new BalanceRunnable(bal2, address);
		final Long start=System.currentTimeMillis();
		ListenableFuture<Long> listenableFuture1 = moreExecutor.submit(runner1);
		ListenableFuture<Long> listenableFuture2 = moreExecutor.submit(runner2);
		SettableFuture<Long> returned = SettableFuture.create();
		Futures.addCallback(listenableFuture1,new FutureBalanceCallback(start,  bal1, returned, balanceProviders ));
		Futures.addCallback(listenableFuture2,new FutureBalanceCallback(start,  bal2, returned, balanceProviders ));
		/* check balance runnable??? */
		/* how to spot providers returning wrong values? */
		Long valRet;
		try {
			valRet = returned.get();
			if(valCache!=null && valCache.equals( valRet ) )
				return valRet;
			
			Long first  = listenableFuture1.get();
			Long second = listenableFuture2.get();
			if(first!=null && first.equals( second ) ) {
				cache.put("b/" + address, first);
				return first;
			}
			if(first != null)	    cache.put("b/" + address, first);
			else if(second!= null)	cache.put("b/" + address, second);
			
		} catch (InterruptedException | ExecutionException e) {
			
		}
		
		
		return getBalance(address,cont+1);

	}

	@Override
	public Long getReceived(String address) {
		Long val = cache.getIfPresent("r/"+address);
		return val;
	}



}
